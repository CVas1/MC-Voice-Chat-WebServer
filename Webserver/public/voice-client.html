<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Voice Chat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 90%;
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
        }

        .status.connecting {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .btn.primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn.danger {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .btn.warning {
            background: linear-gradient(45deg, #feca57, #ff9ff3);
            color: white;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .players-list {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .players-list h3 {
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }

        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: white;
            border-radius: 8px;
            margin-bottom: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-status {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #28a745;
        }

        .player-status.muted {
            background: #ffc107;
        }

        .player-status.deafened {
            background: #dc3545;
        }

        .position-info {
            font-size: 12px;
            color: #666;
        }

        .audio-visualizer {
            background: #2c3e50;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .visualizer-bars {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 60px;
            gap: 2px;
        }

        .bar {
            width: 4px;
            background: linear-gradient(to top, #667eea, #764ba2);
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        .settings {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .settings h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .slider {
            width: 200px;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .log {
            background: #2c3e50;
            color: #ecf0f1;
            border-radius: 10px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
                margin: 10px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 100%;
                max-width: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ® Minecraft Voice Chat</h1>
            <p id="playerInfo">Connecting...</p>
        </div>

        <div id="status" class="status connecting">
            Connecting to voice server...
        </div>

        <div class="controls">
            <button id="joinBtn" class="btn primary">Join Voice Chat</button>
            <button id="muteBtn" class="btn warning" disabled>Mute</button>
            <button id="deafenBtn" class="btn danger" disabled>Deafen</button>
        </div>

        <div class="audio-visualizer">
            <h3 style="color: white; text-align: center; margin-bottom: 15px;">Voice Activity</h3>
            <div class="visualizer-bars" id="visualizer">
                <!-- Bars will be generated by JavaScript -->
            </div>
        </div>

        <div class="players-list">
            <h3>Connected Players</h3>
            <div id="playersList">
                <p style="text-align: center; color: #666;">No players connected</p>
            </div>
        </div>

        <div class="settings">
            <h3>Audio Settings</h3>
            <div class="setting-item">
                <label>Microphone Gain:</label>
                <input type="range" id="micGain" class="slider" min="0" max="2" step="0.1" value="1">
                <span id="micGainValue">1.0</span>
            </div>
            <div class="setting-item">
                <label>Output Volume:</label>
                <input type="range" id="outputVolume" class="slider" min="0" max="1" step="0.1" value="0.8">
                <span id="outputVolumeValue">0.8</span>
            </div>
            <div class="setting-item">
                <label>Voice Activation Threshold:</label>
                <input type="range" id="voiceThreshold" class="slider" min="0" max="100" step="5" value="30">
                <span id="voiceThresholdValue">30</span>
            </div>
        </div>

        <div id="log" class="log"></div>
    </div>

    <script>        class MinecraftVoiceChat {
            constructor() {
                this.ws = null;
                this.audioContext = null;
                this.mediaStream = null;
                this.sourceNode = null;
                this.analyser = null;
                this.gainNode = null;
                this.mediaRecorder = null;
                this.isConnected = false;
                this.isMuted = false;
                this.isDeafened = false;
                this.playerId = null;
                this.username = null;
                this.players = new Map();
                this.audioBuffers = new Map();
                this.isRecording = false;
                
                // Audio settings
                this.micGain = 1.0;
                this.outputVolume = 0.8;
                this.voiceThreshold = 30;
                
                this.init();
            }

            init() {
                this.setupUI();
                this.setupAudioContext();
                this.parseURLParams();
                this.setupVisualizer();
            }

            parseURLParams() {
                const urlParams = new URLSearchParams(window.location.search);
                this.playerId = urlParams.get('player');
                this.username = urlParams.get('username') || 'Unknown Player';
                
                document.getElementById('playerInfo').textContent = `Welcome, ${this.username}!`;
            }

            setupUI() {
                // Control buttons
                document.getElementById('joinBtn').addEventListener('click', () => this.joinVoiceChat());
                document.getElementById('muteBtn').addEventListener('click', () => this.toggleMute());
                document.getElementById('deafenBtn').addEventListener('click', () => this.toggleDeafen());

                // Audio settings
                const micGainSlider = document.getElementById('micGain');
                const outputVolumeSlider = document.getElementById('outputVolume');
                const voiceThresholdSlider = document.getElementById('voiceThreshold');

                micGainSlider.addEventListener('input', (e) => {
                    this.micGain = parseFloat(e.target.value);
                    document.getElementById('micGainValue').textContent = this.micGain.toFixed(1);
                    if (this.gainNode) {
                        this.gainNode.gain.value = this.micGain;
                    }
                });

                outputVolumeSlider.addEventListener('input', (e) => {
                    this.outputVolume = parseFloat(e.target.value);
                    document.getElementById('outputVolumeValue').textContent = this.outputVolume.toFixed(1);
                });

                voiceThresholdSlider.addEventListener('input', (e) => {
                    this.voiceThreshold = parseInt(e.target.value);
                    document.getElementById('voiceThresholdValue').textContent = this.voiceThreshold;
                });
            }

            setupAudioContext() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            setupVisualizer() {
                const visualizer = document.getElementById('visualizer');
                for (let i = 0; i < 32; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'bar';
                    bar.style.height = '2px';
                    visualizer.appendChild(bar);
                }
            }

            async joinVoiceChat() {
                try {
                    this.updateStatus('Requesting microphone access...', 'connecting');
                      // Get microphone access
                    this.mediaStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: 44100,
                            channelCount: 1
                        }
                    });

                    this.setupAudioProcessing();
                    this.connectWebSocket();
                    
                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    this.updateStatus('Failed to access microphone. Please check permissions.', 'error');
                    this.log('Error: ' + error.message);
                }
            }            setupAudioProcessing() {
                // Create audio nodes for visualization
                this.sourceNode = this.audioContext.createMediaStreamSource(this.mediaStream);
                this.analyser = this.audioContext.createAnalyser();
                this.gainNode = this.audioContext.createGain();
                
                // Configure analyser
                this.analyser.fftSize = 2048;
                this.analyser.smoothingTimeConstant = 0.8;
                
                // Set initial gain
                this.gainNode.gain.value = this.micGain;
                
                // Connect nodes for visualization only
                this.sourceNode.connect(this.gainNode);
                this.gainNode.connect(this.analyser);
                
                // Setup MediaRecorder for better audio capture
                this.setupMediaRecorder();
                
                // Start visual processing
                this.startVisualProcessing();
            }            setupMediaRecorder() {
                // Use the best available codec
                let mimeType = 'audio/webm;codecs=opus';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'audio/webm';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/mp4';
                        if (!MediaRecorder.isTypeSupported(mimeType)) {
                            mimeType = ''; // Let the browser choose
                        }
                    }
                }
                
                // Create MediaRecorder with optimized settings
                const options = {
                    audioBitsPerSecond: 48000, // Reduced from 64000 for better real-time performance
                };
                
                if (mimeType) {
                    options.mimeType = mimeType;
                }
                
                this.mediaRecorder = new MediaRecorder(this.mediaStream, options);
                
                this.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0 && this.isConnected && !this.isMuted && this.isRecording) {
                        // Convert to base64 for transmission
                        const reader = new FileReader();
                        reader.onload = () => {
                            const base64Audio = reader.result.split(',')[1];
                            this.sendAudioData(base64Audio);
                        };
                        reader.readAsDataURL(event.data);
                    }
                };
                
                this.mediaRecorder.onerror = (event) => {
                    console.error('MediaRecorder error:', event.error);
                };
                
                // Start continuous recording
                this.startContinuousRecording();
            }

            startContinuousRecording() {
                const recordInterval = 200; // 200ms chunks for better quality vs latency balance
                let isRecordingChunk = false;
                
                const recordChunk = () => {
                    if (!this.mediaRecorder || this.mediaRecorder.state === 'inactive') {
                        if (this.isRecording && !isRecordingChunk) {
                            isRecordingChunk = true;
                            this.mediaRecorder.start();
                            
                            setTimeout(() => {
                                if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                                    this.mediaRecorder.stop();
                                }
                                isRecordingChunk = false;
                            }, recordInterval);
                        }
                    }
                    
                    // Continue the recording loop
                    setTimeout(recordChunk, 50); // Check every 50ms
                };
                
                recordChunk();
            }            startVisualProcessing() {
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                let voiceActivityHistory = [];
                const historySize = 5; // Track last 5 readings for smoother activation
                
                const processVisual = () => {
                    if (!this.analyser) return;
                    
                    this.analyser.getByteFrequencyData(dataArray);
                    
                    // Calculate volume level for voice activation (focus on voice frequencies)
                    const voiceFreqStart = Math.floor(bufferLength * 0.1); // ~2kHz at 44.1kHz
                    const voiceFreqEnd = Math.floor(bufferLength * 0.4);   // ~8kHz at 44.1kHz
                    
                    let voiceSum = 0;
                    for (let i = voiceFreqStart; i < voiceFreqEnd; i++) {
                        voiceSum += dataArray[i];
                    }
                    const voiceVolume = voiceSum / (voiceFreqEnd - voiceFreqStart);
                    
                    // Track voice activity history for smoother detection
                    voiceActivityHistory.push(voiceVolume > this.voiceThreshold);
                    if (voiceActivityHistory.length > historySize) {
                        voiceActivityHistory.shift();
                    }
                    
                    // Activate if at least 3 out of last 5 readings show voice activity
                    const activeCount = voiceActivityHistory.filter(Boolean).length;
                    const shouldRecord = activeCount >= Math.ceil(historySize * 0.6);
                    
                    // Update visualizer with full spectrum for visual feedback
                    this.updateVisualizer(dataArray);
                    
                    // Control recording based on voice activity
                    if (shouldRecord && !this.isMuted && this.isConnected) {
                        if (!this.isRecording) {
                            this.isRecording = true;
                            console.log('Voice activity detected - starting recording');
                        }
                    } else {
                        if (this.isRecording) {
                            this.isRecording = false;
                            console.log('Voice activity stopped - stopping recording');
                        }
                    }
                    
                    requestAnimationFrame(processVisual);
                };
                
                processVisual();
            }connectWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    this.log('Connected to voice server');
                    this.updateStatus('Connected! Joining voice chat...', 'connecting');
                    
                    // Join the voice chat
                    this.ws.send(JSON.stringify({
                        type: 'join',
                        playerId: this.playerId,
                        username: this.username,
                        position: { x: 0, y: 0, z: 0 }
                    }));
                };
                
                this.ws.onmessage = (event) => {
                    this.handleWebSocketMessage(JSON.parse(event.data));
                };
                
                this.ws.onclose = () => {
                    this.isConnected = false;
                    this.updateStatus('Disconnected from voice server', 'error');
                    this.log('Disconnected from server');
                };
                
                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.updateStatus('Connection error', 'error');
                    this.log('Connection error: ' + error.message);
                };
            }

            handleWebSocketMessage(data) {
                switch (data.type) {
                    case 'joined':
                        this.isConnected = true;
                        this.playerId = data.playerId;
                        this.updateStatus('Successfully joined voice chat!', 'connected');
                        this.enableControls();
                        this.log(`Joined as player ID: ${this.playerId}`);
                        break;
                        
                    case 'voice_data':
                        this.playVoiceData(data);
                        break;
                        
                    case 'player_list':
                        this.updatePlayersList(data.players);
                        break;
                        
                    case 'position_update':
                        this.log(`Player ${data.playerId} moved to position: ${JSON.stringify(data.position)}`);
                        break;
                        
                    case 'mute_status':
                        this.isMuted = data.isMuted;
                        this.updateMuteButton();
                        break;
                        
                    case 'deafen_status':
                        this.isDeafened = data.isDeafened;
                        this.updateDeafenButton();
                        break;
                        
                    case 'error':
                        this.log('Server error: ' + data.message);
                        break;
                }
            }            sendAudioData(audioData) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN && !this.isMuted) {
                    this.ws.send(JSON.stringify({
                        type: 'voice_data',
                        audioData: audioData
                    }));
                }
            }            async playVoiceData(data) {
                if (this.isDeafened) return;
                
                try {
                    // Convert base64 audio data back to blob
                    const audioBlob = this.base64ToBlob(data.audioData, 'audio/webm;codecs=opus');
                    
                    // Create audio element for playback
                    const audio = new Audio();
                    const audioUrl = URL.createObjectURL(audioBlob);
                    
                    audio.src = audioUrl;
                    audio.volume = (data.volume || 1.0) * this.outputVolume;
                    
                    // Play the audio
                    audio.play().then(() => {
                        this.log(`Playing voice from ${data.senderUsername} (volume: ${(data.volume || 1.0).toFixed(2)})`);
                        
                        // Clean up URL when audio ends
                        audio.onended = () => {
                            URL.revokeObjectURL(audioUrl);
                        };
                    }).catch(error => {
                        console.error('Error playing audio:', error);
                        URL.revokeObjectURL(audioUrl);
                    });
                    
                } catch (error) {
                    console.error('Error playing voice data:', error);
                }
            }

            base64ToBlob(base64, mimeType) {
                const byteCharacters = atob(base64);
                const byteNumbers = new Array(byteCharacters.length);
                
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                
                const byteArray = new Uint8Array(byteNumbers);
                return new Blob([byteArray], {type: mimeType});
            }

            updateVisualizer(dataArray) {
                const bars = document.querySelectorAll('.bar');
                const step = Math.floor(dataArray.length / bars.length);
                
                bars.forEach((bar, index) => {
                    const value = dataArray[index * step];
                    const height = Math.max(2, (value / 255) * 60);
                    bar.style.height = height + 'px';
                });
            }

            updatePlayersList(players) {
                const playersList = document.getElementById('playersList');
                
                if (players.length === 0) {
                    playersList.innerHTML = '<p style="text-align: center; color: #666;">No players connected</p>';
                    return;
                }
                
                playersList.innerHTML = players.map(player => `
                    <div class="player-item">
                        <div class="player-info">
                            <div class="player-status ${player.isMuted ? 'muted' : ''} ${player.isDeafened ? 'deafened' : ''}"></div>
                            <div>
                                <strong>${player.username}</strong>
                                <div class="position-info">
                                    Position: (${Math.round(player.position.x)}, ${Math.round(player.position.y)}, ${Math.round(player.position.z)})
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('');
            }

            toggleMute() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({ type: 'toggle_mute' }));
                }
            }

            toggleDeafen() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({ type: 'toggle_deafen' }));
                }
            }

            updateMuteButton() {
                const muteBtn = document.getElementById('muteBtn');
                muteBtn.textContent = this.isMuted ? 'Unmute' : 'Mute';
                muteBtn.className = this.isMuted ? 'btn primary' : 'btn warning';
            }

            updateDeafenButton() {
                const deafenBtn = document.getElementById('deafenBtn');
                deafenBtn.textContent = this.isDeafened ? 'Undeafen' : 'Deafen';
                deafenBtn.className = this.isDeafened ? 'btn primary' : 'btn danger';
            }

            enableControls() {
                document.getElementById('muteBtn').disabled = false;
                document.getElementById('deafenBtn').disabled = false;
                document.getElementById('joinBtn').disabled = true;
                document.getElementById('joinBtn').textContent = 'Connected';
            }

            updateStatus(message, type) {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
            }

            log(message) {
                const logElement = document.getElementById('log');
                const timestamp = new Date().toLocaleTimeString();
                logElement.innerHTML += `<div>[${timestamp}] ${message}</div>`;
                logElement.scrollTop = logElement.scrollHeight;
            }
        }

        // Initialize the voice chat when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new MinecraftVoiceChat();
        });
    </script>
</body>
</html>
